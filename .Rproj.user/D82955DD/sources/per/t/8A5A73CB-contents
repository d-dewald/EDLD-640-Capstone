---
title             : "EDLD 640 Capstone"
shorttitle        : "Natural Language Processing for Pedagogy"
author: 
  - name          : "Diana DeWald"
    affiliation   : "1"
    corresponding : yes    # Define only one corresponding author
    address       : "336 Straub Hall University of Oregon, Eugene OR, 97403"
    email         : "ddewald@uoregon.edu"
  - name          : "Dare Baldwin"
    affiliation   : "1"
affiliation:
  - id            : "1"
    institution   : "University of Oregon"

abstract: |

  (will change wording to past tense once project is completed, and will add in results and discussion summary).. 
  
  How is young children's exploration impacted by adult pedagogy? Can we create Machine Learning models to predict how a child will explore the causal features of an object based upon the pedagogy they are exposed to? Our goal is to establish predictive models of preschoolers' causal learning outcomes within educational settings based upon teachers' pedagogical styles. Using pre-existing samples of pedagogy and child outcomes, we...
  
  The rationale for this investigation is that determining the pedagogy-inclusive models predicting children's behavior in educational settings will allow us to predict cases where adult-directed instruction creates positive learning outcomes.
  
  
  <!-- https://tinyurl.com/ybremelq -->
keywords          : "causal learning models, pedagogy, text analysis"
wordcount         : "944"
bibliography      : ["r-references.bib"]
floatsintext      : no
figurelist        : no
tablelist         : no
footnotelist      : no
linenumbers       : yes
mask              : no
draft             : no
documentclass     : "apa6"
classoption       : "man"
output            : papaja::apa6_pdf
editor_options: 
  chunk_output_type: console
---

```{r loading libraries, include = FALSE, warning= FALSE}
library(papaja)
r_refs("r-references.bib")
library(tidyverse)
library(here)
library(rio)
library(tidytext)
library(dplyr)
library(tidyr)

library(devtools)
library(tinytex)
library(readr)
library(magrittr)
library(recipes)
library(psych)
library(finalfit)
library(caret)
library(glmnet)
library(recipes)
library(cutpointr)
library(kableExtra)
library(pastecs)

```

# Introduction
  
  Developmentalists and educators have long debated the benefits of child-directed (Montessori style) exploration contra adult-directed (pedagogical) instruction on learning outcomes.In this project, I investigate 
  
  The truth is that both provide valuable learning opportunities, but questions of how, in what cases, and for which individuals remain fuzzy. While young children (age 3-6) often re-structure their hypotheses about the world based upon self-directed exploration á la Montessori, there are many subjects children cannot master without adult-directed pedagogical guidance (e.g., novel object labels, the alphabet, color and shape labels, historical events, the existence of entities such as germs, etc.). Such subjects are often culturally and linguistically bound, but even causal learning related to the physical properties of objects and entities can benefit from adult-directed pedagogy. Clarifying the extent to which pedagogy supports—and in some cases diminishes—effective causal learning is essential for a) informing teaching strategies in a time when many preparatory schools in the U.S. suffer from a lack of funding and teacher support [@SRCD; @NIERR], and b) elevating early education outcomes following relative dips in school preparedness over the past three years (Jalongo, 2021; [@gonzalez2022school]).
  In early childhood (age 3-6), children learn about causality through both self-directed and adult-directed methods. In recent years, adult-directed early education programs have undergone substantial changes in the U.S., yet the vast majority of causal learning models remain focused on child-directed learning outcomes. Those who have sought to address the impact of adult-directed pedagogy on causal learning describe a pedagogical trade-off model. This model proposes that adult instruction increases the proportion of time children spend exploring an object’s pedagogy-relevant properties but limits their investigation of other properties. Conversely, child-directed exploration is understood to produce broader discovery of the complete set of an object’s causal properties but diminish the time spent investigating any particular property. While such behavioral outcomes are established, little is known about the cognitive mechanisms that drive this pedagogical trade-off, how to computationally map the trade-off, and the extent to which computational models capture individual differences in learning outcomes. Failing to assess the differential impact of pedagogy on causal learning during early childhood limits educators to theories that only take child-directed learning into account. 
  While computational models of children’s causal learning exist (e.g., Kosoy et al., 2022; Gopnik et al. 2004; Sobel, 2014; Oudeyer & Smith, 2014; Twomey & Westermann, 2016; Bonawitz et al., 2022; Colantonio et al., in press), there is no pre-existing model which factors in pedagogy-type as a predictor of learning behaviors. By utilizing machine learning to train models both with-and-without the presence of diverse pedagogy categories, we can greatly expand the predictive power of causal learning models, which are currently limited to child-directed learning predictors. 
  Our long-term goal is to establish predictive models of preschoolers’ causal learning outcomes within naturalistic settings based upon teachers’ pedagogical styles. The overall objective is to elucidate how interactions between pedagogy type, attentional patterns, and exploratory behavior inform competing computational models of causal learning outcomes and to train a best-performing model via machine learning. Our central hypotheses is as follows: causal learning models will perform best when taking granular pedagogy types into account. We aim to create and test competing computational models related to the interaction between pedagogy type and causal learning. We predict that prior computational models of causal learning that contain fewer pedagogy categories (or do not take pedagogy into account) will perform worse than pedagogy-diverse models of causal learning. Upon completion, our expected outcomes are to have established the interaction between adult instruction style and children’s visual attention processes and exploratory behaviors within physical causal learning domains. These results will a) add valuable evidence to clarify developmentalists’ theoretical and computational accounts of causal learning, and b) pave a way forward to support educators in developing effective curriculum for young students during a time of immense educational resource shortages.

# Methods
  In Fall of 2022, we conducted a survey of undergraduate students (N = 168) at the University of Oregon, asking participants to report how they would teach a child about the causal properties of a novel object. Participants were randomly sorted into 2 conditions. In the 'enhance' condition, participants were asked to generate pedagogy for two object properties intended to produce broad exploratory behaviors from a child (ex: "What would you say to introduce this toy in a way that encourages wide-ranging exploration?"). In the 'constrain' condition, participants were asked to generate pedagogy intended to produce limited exploratory behaviors from a child (ex: "What would you say to introduce this toy in a way that discourages wide-ranging exploration?"). 
  
  We then (in the works) created a coding classifier system pairing participant-generated pedagogy with 7 pedagogy-type categories from previous research. These 7 pedagogy categories were linked to specific child outcomes from prior studies conducted by us as well as other labs. Using our child data outcome data paired with the coded participant-generated pedagogy, we are creating models to capture how well participants in our survey generated pedagogy which was most likely to produce the desired child outcomes.

### outline: describe models (see whether bagged tree or random forest model better predicts the sentiment of pedagogy--use this to see if some pedagogy sentiment groups are tied to certain child outcomes), coding system, variables, etc.

### Coding system: based on rank order created for gen survey


```{r data cleaning, warning = FALSE}

# loading datasets

mydata <- import(here("data", "pedagogy_data.xlsx"))
textdata <- import(here("data", "text_data.xlsx"))

# fixing demographic variables


# pivoting longer
mydata <- mydata %>%
  pivot_longer(cols = starts_with("f"), 
               names_to = "func", 
               values_to = "pedagogy")

# renaming two variables in funct column and getting rid of old func column
fun <- c(fsqueak = "squeak", flight = "light")

mydata$funct <- 
  as.character(fun[mydata$func])

mydata$func <- NULL
rm(fun)

```

```{r initial plots, warning = FALSE}

# parsing words from the 'pedagogy' (text) column
tidy_words <- mydata %>%
  unnest_tokens(word, pedagogy)

# removing numbers
tidy_words <- tidy_words[-grep("\\b\\d+\\b", tidy_words$word),]

# removing common/under-informative words
exclu <- tibble(word = c("the", "this", "I"))

tidy_words <- tidy_words %>%
  anti_join(exclu, by = "word")


#plot
tidy_words %>% 
  anti_join(stop_words) %>% 
  count(word, sort = TRUE) %>% 
  mutate(word = reorder(word, n)) %>% # make y-axis ordered by n
  slice(1:15) %>% # select only the first 15 rows
  ggplot(aes(n, word)) +
  geom_col(fill = "royalblue", alpha = .7) +
  scale_x_continuous(expand = c(0,0)) +
  theme_minimal() +
  theme(
    panel.grid.major.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.x = element_line(color = "gray80")
  ) +
  labs(
    x = "Word Frequency",
    y = "Word",
    title = "Top 15 most frequently occurring words across all pedagogy types",
  )
```


```{r word cloud, warning=FALSE}

# visualing: word cloud
library(wordcloud)

tokens = textdata %>%
  unnest_tokens(word, text) %>%
  anti_join(stop_words)

# top words
word_count = tokens%>%
  group_by(word)%>%
  summarise(count = n())%>%
  arrange(desc(count))%>%
  slice(1:10)


# word cloud--zoom in
cloud <- tokens %>%
  group_by(source, word) %>%
  summarise(count = n())%>%
  arrange(desc(count))%>%
  slice(1:10)
  

wordcloud(tokens$word, max.words = 75, colors=brewer.pal(6, "Dark2"))


```

##discussion of graph by condition


```{r, warning=FALSE}
tidy_words %>% 
  group_by(condition) %>%
  anti_join(stop_words) %>% 
  count(word, sort = TRUE) %>% 
  mutate(word = reorder(word, n)) %>% # make y-axis ordered by n
  slice(1:15) %>% # select only the first 15 rows
  ggplot(aes(n, word, fill = condition)) +
  geom_col(alpha = .7) +
  facet_wrap(~condition) +
  scale_x_continuous(expand = c(0,0)) +
  theme_minimal() +
  theme(
    panel.grid.major.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.x = element_line(color = "gray80")
  ) +
  labs(
    x = "Word Frequency",
    y = "Word",
    title = "Top 15 most frequently occurring words by condition",
  )
```


```{r analysis-preferences, include = FALSE, warning = FALSE}
# Seed for random number generation
set.seed(42)
knitr::opts_chunk$set(cache.extra = knitr::rand_seed)
```


### sentiment analysis


```{r, warning = FALSE}

# devtools::install_github("rstudio/reticulate")

 require(reticulate)

Sys.setenv(RETICULATE_PYTHON = "C:/Users/ddewa/AppData/Local/r-miniconda/envs/capstone/python.exe")

conda_install(envname = 'capstone', 
              packages = 'torch', 
              pip = TRUE, 
              force = TRUE)

conda_install(envname = 'capstone',
              packages = 'transformers',
              pip=TRUE, 
              force=TRUE)

conda_install(envname = 'capstone',
              packages = 'protobuf',
              pip=TRUE, 
              force=TRUE)


reticulate::use_condaenv("capstone")

transformers <- reticulate::import('transformers')

model_path <- "cardiffnlp/twitter-xlm-roberta-base-sentiment"

sentiment_task <- transformers$pipeline("sentiment-analysis", 
                                         model=model_path, 
                                         tokenizer=model_path)



```



### Sentiment by analysis tool

```{r, warning=FALSE}
# sentiment analysis
library(RColorBrewer)


# sentiment1 = textdata %>% #this allows us to retain the row number/the tweet
#  unnest_tokens(word, text)%>% # this unnests the tweets into words
#  anti_join(stop_words)%>% #removes common words (stop words)
#  left_join(get_sentiments("bing"))

#sentiment2 = textdata %>% #this allows us to retain the row number/the tweet
#  unnest_tokens(word, text)%>% # this unnests the tweets into words
#  anti_join(stop_words)%>% #removes common words (stop words)
#  left_join(get_sentiments("nrc"))

#sentiment3 = textdata %>% #this allows us to retain the row number/the tweet
#  unnest_tokens(word, text)%>% # this unnests the tweets into words
#  anti_join(stop_words)%>% #removes common words (stop words)
#  left_join(get_sentiments("loughran"))

#sentiment4 = textdata %>% #this allows us to retain the row number/the tweet
#  unnest_tokens(word, text)%>% # this unnests the tweets into words
#  anti_join(stop_words)%>% #removes common words (stop words)
#  left_join(get_sentiments("afinn"))


sentimentdata <- import(here("data", "sentiment_an.xlsx"))
sentiment <- import(here("data", "sentiment.xlsx"))

sentiment_by_condition <- sentimentdata %>%
  group_by(condition, analysis) %>%
  count(sentiment)

sentiment <- sentiment %>%
  group_by(condition) %>%
  count(sentiment)

# table of sentiment for four groups ("bing", "nrc", "afinn", "loughran")
sentimenttable <- import(here("data", "sentiment_table.xlsx"))
table <- sentimenttable[1:2, 2:11]

options(kableExtra.auto_format = FALSE)
library(kableExtra)


table %>% 
  kbl(caption = "Sentiment by analysis tool") %>%
  kable_classic(html_font = "Cambria") %>%
  column_spec(column = 1:10, width = "0.57in") %>%
  footnote(general_title = "Note.", footnote_as_chunk=TRUE, threeparttable=TRUE, general = "Positive (Pos) and Negative (Neg) sentiment analysis by individual words using 4 analysis tools: bing, nrc, loughran, and afinn. Results demonstrate that Total Positive & Negative sentiment was roughly equal by condition (enhance or constrain). However, positive sentiment was slightly higher for the enhance condition and negative sentiment was slight higher for the constrain condition, which is the expected result.") 


```








## Part 1: Predicting a Categorical Outcome (sentiment: positive or negative) using Regularized Logistic Regression

```{r part1_prep, warning = FALSE}

# Recipe for the sentiment dataset

outcome <- c('sentiment')

ID <- c('id')

categorical <- c('condition', 'source', 'function')

 blueprint <- recipe(x  = sentiment,
                    vars  = c(categorical, outcome, ID),
                    roles = c(rep('predictor',3), 'outcome', 'ID')) %>%
  step_zv(all_of(categorical)) 

```

### Task 1.1: split dataset into training and testing

```{r 1.1, warning = FALSE}
# Let the training data have the 80% of cases and the test data have the 20% of the cases.

set.seed(11102021)  # for reproducibility
  
sen      <- sample(1:nrow(sentiment), round(nrow(sentiment) * 0.8))
sen_train  <- sentiment[sen, ]
sen_test  <- sentiment[-sen, ]

```


### Task 1.2: 10-fold cross-validation without regularization

```{r 1.2, warning = FALSE}

set.seed(11152021) # for reproducibility

sen_tr = sen_train[sample(nrow(sen_train)),]

  # Creating 10 folds with equal size

folds = cut(seq(1,nrow(sen_tr)),breaks=10,labels=FALSE)
  
  # Creating the list for each fold 
sen.indices <- vector('list',10)

      for(i in 1:10){
        sen.indices[[i]] <- which(folds!=i)
      }
    

 cv <- trainControl(method    = "cv",
                   index           = sen.indices,
                   classProbs      = TRUE,
                   summaryFunction = mnLogLoss)
    
      
# Train the model
 caret_mod <- caret::train(blueprint, 
                          data      = sen_tr, 
                          method    = "glm",
                          family    = 'binomial',
                          metric    = 'logLoss',
                          trControl = cv)
 
 caret_mod
 
 # Evaluate the model on the test data

# Predict the probabilities for the observations in the test dataset
 
 predicted_test <- predict(caret_mod, sen_test, type='prob')

head(predicted_test)



# Evaluate the model on the test dataset
predicted_te <- predict(caret_mod, sen_test)

predicted_te <- as.numeric(predicted_te)
sen_test_numeric <- sen_test$sentiment_numeric


predicted_eval <- data.frame(predicted_te, sen_test_numeric)
predicted_eval <- predicted_eval[complete.cases(predicted_eval), ]


rsq_te <- cor(predicted_eval$predicted_te,predicted_eval$sen_test_numeric)^2
rsq_te

mae_te <- mean(abs(predicted_eval$sen_test_numeric - predicted_eval$predicted_te))
 mae_te

rmse_te <- sqrt(mean((predicted_eval$sen_test_numeric - predicted_eval$predicted_te)^2))
rmse_te
```

  Model performance:

### Task 1.3: 10-fold cross-validation with ridge penalty
```{r 1.3 ridge, warning = FALSE}
 caret::getModelInfo()$glmnet$parameters

# currently getting this error when running ridge and lasso penalty: Error in { : 
#  task 1 failed - "error in evaluating the argument 'x' in selecting a method for function 'as.matrix': invalid class 'NA' to dup_mMatrix_as_dgeMatrix"
# In addition: There were 20 warnings (use warnings() to see them)


grid_ridge <- data.frame(alpha = 0, lambda = seq(0.01,2,.01)) 
# grid
  
#  ridge <- caret::train(blueprint, 
#                        data      = sen_train, 
#                        method    = "glmnet",
#                        family = 'binomial', 
#                        metric = 'logLoss',
#                        trControl = cv,
#                        tuneGrid  = grid_ridge)
  
# ridge$results


# ridge$bestTune
  
# plot(ridge)
```


The optimal lambda value for a lasso penalty was _____


According to the second lasso model, the optimal lambda value for lasso penalty is _______


### Find and report the most important 10 predictors of sentiment and their coefficients. 




## Data analysis: Logistic regression predicting whether a particular object function was discovered

```{r, include = TRUE, warning= FALSE, include=FALSE}

omsi <- import(here("data", "omsidata.xlsx"))

omsi$condition <- as.factor(omsi$condition)

outcome <- c('squeaker_discovered')

ID <- c('participant')

categorical <- c('condition')

# Problem: currently getting an error when I try to train the model.The error is coming from step_medianimpute(). step_medianimpute() requires all the variables to be numeric but it is being passed factor variables with all_predictors().One way to fix this problem is by rearranging your recipe to create dummy variables before you impute.need to dummy code

blueprint <- recipe(x  = omsi,
                    vars  = c(categorical, outcome, ID),
                    roles = c(rep('predictor'),'outcome','ID')) %>%
  step_indicate_na(all_of(categorical)) %>%
  step_zv(all_of(categorical)) %>%
    step_num2factor(outcome,
                  transform = function(x) x + 1,
                  levels=c('Y', 'N')) %>%
  step_num2factor(condition, 
                  transform = function(x) x + 1,
                  levels=c('ped1', 'baseline', 'interrupted', 'naive'))
 
blueprint


# let's split into testing and training sets
# Let the training data have the 80% of cases and the test data have the 20% of the cases.

set.seed(11102021)  # for reproducibility
  
ped     <- sample(1:nrow(omsi), round(nrow(omsi) * 0.8))
ped_train  <- omsi[ped, ]
ped_test  <- omsi[-ped, ]


# 10 fold cross validation


set.seed(11152021) # for reproducibility

omsi_tr = ped_train[sample(nrow(ped_train)),]

  # Creating 10 folds with equal size (creating an empty list not currently working)

folds_omsi = cut(seq(1,nrow(omsi_tr)),breaks=10,labels=FALSE)
  
# code currently providing error when I try to create an empty list
  # Creating the list for each fold 
# omsi_indices <- vector(mode = 'list',length = 10)
#      for(i in 1:10){
#        omsi_indices[[i]] <- which(folds_omsi!=i)
#      }
    
set.seed(125)

 cv <- trainControl(method    = "cv",
                      classProbs      = TRUE,
                   summaryFunction = mnLogLoss,
                   number = 10)
 
    
      
# Train the model
  
# ped_mod <- caret::train(blueprint, 
#                          data      = omsi_tr, 
#                          method    = "glm",
#                          family    = 'binomial',
#                          metric    = 'logLoss',
#                          trControl = cv)

# ped_mod

# Evaluate the model on the test data

# Predict the probabilities for the observations in the test dataset

# predicted_test <- predict(ped_mod, omsi_test, type='prob')

# head(predicted_test)


# sentiment analysis notes

```

## K-nearest neighbors algorithm to predict rank ordered exploration-promotion

# import data
textdummy <- import(here("data", "text_data_dummy.xlsx"))

# train and test split

set.seed(10152022) # for reproducibility

loc <- sample(1:nrow(textdummy), round(nrow(textdummy) * 0.9))
rank_tr <- textdummy[loc, ]
rank_te <- textdummy[-loc, ]


# create row indices for 10-folds

  #randomly shuffle training data
rank_tr = rank_tr[sample(nrow(rank_tr)),]


    # Create 10 folds with equal size

      folds = cut(seq(1,nrow(rank_tr)),breaks=10,labels=FALSE)
  
    # Create the list for each fold 
      
      my.indices <- vector('list',10)
      for(i in 1:10){
        my.indices[[i]] <- which(folds!=i)
      }

# Cross-validation settings
      
  cv <- trainControl(method = "cv",
                     index  = my.indices)
  
require(caret)
require(kknn)

getModelInfo()$kknn$parameters


# Hyperparameter Tuning Grid
  
  grid <- expand.grid(kmax    = 3:25,
                     distance = c(1,2,3),
                     kernel   = c('epanechnikov','rectangular'))
  grid
  
  
require(doParallel)

ncores <- 8    

cl <- makePSOCKcluster(ncores)

registerDoParallel(cl)


# Train the model


outcome <- c('rank')

ID <- c('id')

categorical <- c('condition', 'source', 'function')


blueprint_textdummy <- recipe(x  = textdummy,
                    vars  = c(categorical, outcome, ID),
                    roles = c(rep('predictor',3), 'outcome', 'ID')) 


  caret_knn <- caret::train(blueprint_textdummy, 
                                        data      = rank_tr,
                                        method    = "kknn",
                                        trControl = cv,
                                        tuneGrid  = grid)




# Results (in progress)

# Discussion (in progress)


\newpage

# References
We used packages from `r cite_r("r-references.bib")` for all our analyses.

\begingroup
\setlength{\parindent}{-0.5in}
\setlength{\leftskip}{0.5in}

<div id="refs" custom-style="Bibliography"></div>
\endgroup
